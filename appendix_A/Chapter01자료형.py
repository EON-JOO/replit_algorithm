# <수 자료형 - 실수형>
a = 1e9 # 10억의 지수 표현 방식
print(a)
a = 75.25e1 # 752.5
print(a)
a = 3954e-3 # 3.954
print(a)
print("-----")

a = 0.3 + 0.6
print(a) # 컴퓨터는 실수를 정확히 표현하지 못함
if a == 0.9:
  print(True)
else:
  print(False)
print("-----")
  
# 소수점 값을 비교하는 작업이 필요한 문제 -> round 함수 이용
# round(실수형 데이터, 반올림하고자 하는 위치-1)
# 흔히 코테 문제에서는 실수형 데이터를 비교할 때 소수점 다섯 번째 자리에서 반올림한 결과가 같으면 정답으로 인정하는 식으로 처리
a = 0.3 + 0.6
print(round(a, 4))
if round(a, 4) == 0.9:
  print(True)
else:
  print(False)
print("-----")

# <수 자료형의 연산>
a, b = 7, 3
print(a / b) # 나누기(실수형으로 처리)
print(a % b) # 나머지(홀/짝수 구분할 때 사용)
print(a // b) # 몫
print(a ** b) # 거듭제곱
print("-----")

# <리스트 자료형>
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)
print(a[4]) # 인덱스 4, 즉 다섯 번째 원소에 접근
a = list() # 빈 리스트 선언 (1)
print(a)
a = [] # 빈 리스트 선언 (2)
print(a)
# 크기가 n이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)
print("-----")

a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1]) # 뒤에서 첫 번째 원소 출력
print(a[-3]) # 뒤에서 세 번째 원소 출력
a[3] = 7 # 네 번째 원소 값 변경
print(a)
print(a[1:4]) # 두 번째 원소부터 네 번째 원소까지
print("-----")

# 리스트 컴프리헨션
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array1 = [i for i in range(20) if i % 2 == 1]
print(array1)
# 1부터 9까지의 수의 제곱 값을 포함하는 리스트
array2 = [i ** 2 for i in range(1, 10)]
print(array2)
# n * m 크기의 2차원 리스트 초기화
n, m = 3, 4
array3 = [[0] * m for _ in range(n)]
print(array3)
print("-----")
# 잘못된 2차원 리스트 초기화 방법
array4 = [[0] * m] * n
print(array4)
array4[1][1] = 5
print(array4) # 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문 -> 특정한 크기를 가지는 2차원 리스트를 초기화할 때는 리스트 컴프리헨션을 이용
print("-----")

# 리스트 관련 기타 메서드
a = [1, 4, 3]
print("기본 리스트 :", a)
a.append(2) # 리스트에 원소 삽입 : O(1)
print("삽입 :", a)
a.sort() # 오름차순 정렬
print("오름차순 정렬 :", a)
a.sort(reverse = True)
print("내림차순 정렬 :", a)
a.reverse() # 리스트 원소 뒤집기
print("원소 뒤집기 :", a)
a.insert(2, 3) # 특정 인덱스에 데이터 추가 : O(n)
# 중간에 원소 삽입한 뒤에, 리스트의 원소 위치를 조정
print("인덱스 2에 3 추가 :", a)
print("값이 3인 데이터 개수 :", a.count(3))
a.remove(1) # 특정 값 데이터 삭제 : O(n)
# 중간에 원소 삭제한 뒤에, 리스트의 원소 위치를 조정
print("값이 1인 데이터 삭제 :", a)

# 특정한 값의 원소를 모두 제거하려면
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = [3, 5]
# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result)
print("-----")

# <문자열 자료형>
# 문자열 초기화
data = 'Hello World'
print(data)
data = "Don't you know \"Python\""
print(data)
# 문자열 연산
a = "Hello"
b = "World"
print(a + " " + b)
a = "String"
print(a * 3)
a = "ABCDEF"
print(a[2 : 4])

# <튜플 자료형>
# 튜플은 한 번 선언된 값을 변경할 수 없고, 소괄호 이용
a = (1, 2, 3, 4)
print(a)
print("-----")
# a[2] = 7 "안돼"
# 튜플 자료형은 그래프 알고리즘을 구현할 때 자주 사용됨. 예로 다익스트라 최단 경로 알고리즘처럼 최단 경로를 찾아주는 알고리즘 내부에서 우선순위 큐를 이용하는데 해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않음. 비용과 노드 번호라는 서로 다른 성질의 데이터를 튜플로 묶어서 관리하는 것이 관례

# <사전 자료형>
# 키-값 쌍을 데이터로 가짐, 변경 불가능한 데이터를 키로 사용
# 내부적으로 해시 테이블을 이용 -> 기본적으로 데이터 검색 및 수정에 있어서 O(1)의 시간에 처리 가능, 즉 키-값 쌍으로 구성된 데이터를 처리함에 있어서 리스트보다 훨씬 빠르게 동작함
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'
print(data)

# 1~10,000,000의 숫자 중 최대 10,000개의 숫자를 선택, 이후에 특정한 숫자가 주어졌을 때 이 숫자가 선택되었는지 판단하는 문제 : 리스트를 이용한다면, 1부터 10,000,000까지의 각 숫자가 '선택되었는지를 저장할 수 있는' 리스트를 만들어야 함. 즉 1,000만 개 데이터를 저장할 수 있는 리스트를 만들어야 하므로 메모리 공간 낭비, 이 중 999만 개 가량의 데이터를 쓰이지 않음
# 사전 자료형을 이용하는 경우, 1,000만 개의 데이터를 담을 필요가 없으며 10,000개의 데이터만 사전 자료구조에 들어가므로 훨씬 적은 메모리 공간을 사용할 수 있음

# 사전 자료형에 특정한 원소가 있는지 검사할 때
if '사과' in data:
  print("'사과'를 키로 갖는 데이터가 존재합니다.")

# 사전 자료형 관련 함수
key_list = data.keys() # 키 데이터만 담은 리스트
val_list = data.values() # 값 데이터만 담은 리스트
print(key_list)
print(val_list)
# 각 키에 따른 값을 하나씩 출력
for key in key_list:
  print(data[key])
print("-----")

# <집합 자료형>
# 집합은 기본적으로 리스트 혹은 문자열을 이용해서 만들 수 있음, 중복을 허용하지 않으며 순서가 없음 (사전 자료형과 집합 자료형은 키가 존재하지 ㅇ낳고, 값 데이터만을 담게 됨)
# 특정 원소가 존재하는지 검사하는 연산의 시간 복잡도는 O(1)
# 특정한 데이터가 이미 등장한 적이 있는지 여부를 체크할 때 매우 효과적
# 집합 자료형 초기화 방법 (1)
data = set([1, 1, 2, 3, 4, 4, 5])
print(data)
# 집합 자료형 초기화 방법 (2)
data = {1, 1, 2, 3, 4, 4, 5}
print(data)

# 집합 자료형의 연산 : 합집합, 교집합, 차집합
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])
print(a | b) # 합집합
print(a & b) # 교집합
print(a - b) # 차집합
print("-----")

# 집합 자료형 관련 함수
# add(), remove() 함수 모두 시간 복잡도 O(1)
data = set([1, 2, 3])
print(data)
data.add(4) # 새로운 원소 추가
print(data)
data.update([5, 6]) # 새로운 원소 여러 개 추가
print(data)
data.remove(3) # 특정한 값을 갖는 원소 삭제
print(data)